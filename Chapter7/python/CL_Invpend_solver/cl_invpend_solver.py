# -*- coding: utf-8 -*-
"""CL_Invpend_solver.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HQJpF_Cze2rIjD99yW2M-OXbNrUogZF_
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

def inverted_pendulum_k1(t, x):
    # Constants
    g = 9.8
    l = 1
    m = 1
    M = 1

    # State feedback gains
    k = np.array([-16.0203, -15.2428, -98.6852, -28.1028])

    # Intermediate calculations
    d1 = M + m * (1 - np.cos(x[2]) ** 2)
    d2 = l * d1

    # State feedback
    F = -np.dot(k, x)

    # State derivatives
    xp = np.zeros(4)
    xp[0] = x[1]
    xp[1] = (F + m * l * x[3] ** 2 * np.sin(x[2]) - m * g * np.sin(x[2]) * np.cos(x[2])) / d1
    xp[2] = x[3]
    xp[3] = (-F * np.cos(x[2]) - m * l * x[3] ** 2 * np.sin(x[2]) * np.cos(x[2]) + (M + m) * g * np.sin(x[2])) / d2

    return xp

# Initial conditions: [x, v, theta, omega]
x0 = [0, 0, 0.26, 0]

# Time span
t_span = (0, 4)
t_eval = np.linspace(t_span[0], t_span[1], 400)  # 400 points within 4 seconds

# Solve the ODE
sol = solve_ivp(inverted_pendulum_k1, t_span, x0, t_eval=t_eval, max_step=1e-2)

# Convert theta from radians to degrees for plotting
theta_deg = sol.y[2] * 180 / np.pi

# Plotting
plt.plot(sol.t, sol.y[0], 'k', label='x (m)')
plt.plot(sol.t, theta_deg, '-.k', label='Î¸ (degrees)')
plt.grid(True)
plt.xlabel('Time (sec)')
plt.ylabel('State Variables')
plt.legend()
plt.gca().set_prop_cycle(None)  # Reset the color cycle
for line in plt.gca().get_lines():
    line.set_linewidth(2)
plt.show()