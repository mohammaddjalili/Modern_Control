# -*- coding: utf-8 -*-
"""DC_motor_LTR1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19CjaVgcYV6jFcv3PL2UvsJQ5P-mKoGhu
"""

# Global parameter container
class Parameters:
    def __init__(self, Tl):
        self.Tl = Tl

# Define the function equivalent to DC_motor_LTR1
def DC_motor_LTR1(t, X, Par):
    # Model of The Real System
    x = X[:3]
    A = np.array([[0, 1, 0],
                  [0, 0, 4.438],
                  [0, -12, -24]])
    B = np.array([[0, 0],
                  [0, -7.396],
                  [20, 0]])
    C = np.array([1, 0, 0])
    y = C @ x

    # Model of the observer with disturbance Tl
    xh = X[3:]
    Ah = np.array([[0, 1, 0, 0],
                   [0, 0, 4.438, -7.396],
                   [0, -12, -24, 0],
                   [0, 0, 0, -1]])
    Bh = np.array([0, 0, 20, 0])
    Ch = np.array([1, 0, 0, 0])

    # State feedback and state observer gains
    k = np.array([3.0000, 0.8796, 0.1529, -1.8190])
    G = np.array([-1.0000, 235.7440, -978.1707, -20.4870])

    # Final Equations
    Tl = Par.Tl * np.exp(-t)  # Exponential disturbance
    v = -k @ xh
    u = np.array([v, Tl])

    xhp = Ah @ xh + Bh * v + G * (y - Ch @ xh)
    xp = A @ x + B @ u
    return np.concatenate((xp, xhp))